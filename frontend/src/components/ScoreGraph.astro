---
/**
 * Optional props: set a refresh rate and/or override window
 * <ScoreGraphRealtime refreshMs={5000} />
 */
const { refreshMs = 5000 } = Astro.props;
---

<div style="width:100%;max-width:1100px">
  <canvas id="scoreChart"></canvas>
</div>

<script type="module">
  import Chart from "chart.js/auto";
  import "chartjs-adapter-luxon";

  const refreshMs = ${JSON.stringify(refreshMs)};

  // Stable, “CTF-ish” palette (repeat-safe)
  const palette = [
    "#00e5ff","#ff3d00","#76ff03","#ffea00","#d500f9",
    "#1de9b6","#2979ff","#ff9100","#f50057","#00c853",
    "#c6ff00","#651fff"
  ];

  // Give each player a stable color based on their name
  function colorFor(name) {
    let h = 0;
    for (let i = 0; i < name.length; i++) h = (h * 31 + name.charCodeAt(i)) >>> 0;
    return palette[h % palette.length];
  }

  function buildCumulativeSeries({ completions, pointsById, playerUsernames, competitionStart, competitionEnd }) {
    // Sort solves by time
    const sorted = (completions ?? [])
      .filter(c => !c.is_admin)
      .slice()
      .sort((a, b) => new Date(a.completed_at) - new Date(b.completed_at));

    // cumulative totals
    const total = {};
    for (const u of playerUsernames) total[u] = 0;

    // start with an explicit point at start time (so lines begin at 0)
    const series = {};
    for (const u of playerUsernames) {
      series[u] = [{ x: competitionStart, y: 0 }];
    }

    for (const c of sorted) {
      const u = c.username;
      if (!(u in total)) continue; // ignore unknown users
      const pts = pointsById[String(c.task_id)] ?? 0;
      total[u] += pts;
      series[u].push({ x: c.completed_at, y: total[u] });
    }

    // Ensure each line reaches the end time (flat line to end)
    for (const u of playerUsernames) {
      const last = series[u][series[u].length - 1];
      if (!last || last.x !== competitionEnd) {
        series[u].push({ x: competitionEnd, y: last?.y ?? 0 });
      }
    }

    return { series, competitionStart, competitionEnd, totals: total };
  }

  const ctx = document.getElementById("scoreChart");

  // Create chart once
  const chart = new Chart(ctx, {
    type: "line",
    data: { datasets: [] },
    options: {
      responsive: true,
      parsing: false,
      animation: {
        duration: 300, // small “tick” animation on updates
      },
      plugins: {
        legend: {
          position: "top",
          labels: { usePointStyle: true },
          // HTB/pico style: click legend to toggle lines
          onClick(e, item, legend) {
            const idx = item.datasetIndex;
            const meta = legend.chart.getDatasetMeta(idx);
            meta.hidden = meta.hidden === null ? !legend.chart.data.datasets[idx].hidden : null;
            legend.chart.update();
          },
        },
        tooltip: {
          mode: "nearest",
          intersect: false,
          callbacks: {
            label: (ctx) => {
              const v = ctx.parsed?.y ?? ctx.raw?.y;
              return `${ctx.dataset.label}: ${v} pts`;
            },
          },
        },
      },
      interaction: { mode: "nearest", intersect: false },
      elements: {
        line: { borderWidth: 2 },
        point: { radius: 0, hoverRadius: 5 }, // pico/HTB often no points, only on hover
      },
      scales: {
        x: {
          type: "time",
          time: {
            tooltipFormat: "yyyy-LL-dd HH:mm:ss",
            displayFormats: { hour: "HH:mm", minute: "HH:mm" },
          },
          title: { display: true, text: "Time" },
        },
        y: {
          beginAtZero: true,
          title: { display: true, text: "Points" },
        },
      },
    },
  });

  // Keep dataset order consistent: highest score on top (like CTF UIs)
  function rankPlayers(totals, playerUsernames) {
    return playerUsernames.slice().sort((a, b) => (totals[b] ?? 0) - (totals[a] ?? 0) || a.localeCompare(b));
  }

  function applyData(payload) {
    const { series, competitionStart, competitionEnd, totals } = buildCumulativeSeries(payload);
    const players = rankPlayers(totals, payload.playerUsernames);

    // Update axes window
    chart.options.scales.x.min = competitionStart;
    chart.options.scales.x.max = competitionEnd;

    // Rebuild datasets in rank order
    chart.data.datasets = players.map((player) => ({
      label: player,
      data: series[player] ?? [{ x: competitionStart, y: 0 }, { x: competitionEnd, y: 0 }],
      borderColor: colorFor(player),
      backgroundColor: colorFor(player),
      stepped: true,     // ✅ key: “solve jumps” like picoCTF/HTB
      tension: 0,
      fill: false,
    }));

    chart.update();
  }

  async function fetchAndUpdate() {
    const res = await fetch("/api/completions", { cache: "no-store" });
    if (!res.ok) return;
    const payload = await res.json();
    applyData(payload);
  }

  // initial render
  await fetchAndUpdate();

  // polling loop
  const timer = setInterval(fetchAndUpdate, refreshMs);

  // cleanup if page navigates (Astro view transitions / SPA-style nav)
  window.addEventListener("beforeunload", () => clearInterval(timer));
</script>