---
export const prerender = false;

import "../styles/global.css";
import { getCurrentUser } from "../lib/session";
import { getAllUsers, type User } from "../lib/users";
import { initTasksTable, getAllTasks, type Task } from "../lib/tasks";
import { getCompetitionEnd } from "../lib/settings";
import Header from "../components/Header.astro";

const user = await getCurrentUser(Astro.request);
const competitionEnd = getCompetitionEnd();
const FREEZE_MINUTES = 15;
let leaderboardFrozen = false;
if (competitionEnd) {
  const endTime = new Date(competitionEnd).getTime();
  const msRemaining = endTime - Date.now();
  leaderboardFrozen = msRemaining > 0 && msRemaining <= FREEZE_MINUTES * 60 * 1000;
}
let users: User[] = [];

try {
  users = await getAllUsers();
} catch (error) {
  console.warn("Failed to load users for leaderboard", error);
  users = [];
}

let dbTasks: Task[] = [];
try {
  await initTasksTable();
  dbTasks = await getAllTasks();
} catch (error) {
  console.warn("Failed to load tasks for leaderboard", error);
}
const pointsById = new Map(dbTasks.map((t) => [String(t.id), t.points]));

const leaderboard = users
  .filter((entry) => !entry.is_admin)
  .map((entry) => {
    const completed = entry.completed_tasks || [];
    const totalPoints = completed.reduce((sum, taskId) => sum + (pointsById.get(taskId) ?? 0), 0);
    return {
      id: entry.id,
      username: entry.username,
      completedCount: completed.length,
      totalPoints,
    };
  })
  .sort((a, b) => {
    if (b.totalPoints !== a.totalPoints) return b.totalPoints - a.totalPoints;
    if (b.completedCount !== a.completedCount) return b.completedCount - a.completedCount;
    return a.username.localeCompare(b.username);
  });

const currentUserIndex = user
  ? leaderboard.findIndex((entry) => entry.username === user.username)
  : -1;
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <title>Leaderboard - BETA-CODE</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet" />
  </head>
  <body>
    <Header user={user} />

    <main class="leaderboard-page">
      <div class="leaderboard-intro">
        <h1>Leaderboard</h1>
        <p class="p-text">Track the top performers and see how you rank against the community.</p>
        {user && currentUserIndex >= 0 && (
          <p class="leaderboard-rank">
            Your rank: <strong>#{currentUserIndex + 1}</strong>
          </p>
        )}
      </div>
      {leaderboardFrozen ? (
        <div class="leaderboard-frozen">
          <h2>Leaderboard Frozen</h2>
          <p>The leaderboard has been hidden for the final {FREEZE_MINUTES} minutes of the competition. Keep solving problems â€” results will be revealed when time is up!</p>
        </div>
      ) : (
        <>
          <div class="graph-section">
            <div class="graph-card">
              <canvas id="completionGraph"></canvas>
            </div>
          </div>

          {leaderboard.length === 0 ? (
            <div class="leaderboard-empty">
              <p>No scores yet</p>
            </div>
          ) : (
            <div class="leaderboard-card">
              <table class="leaderboard-table">
                <thead>
                  <tr>
                    <th>Rank</th>
                    <th>Player</th>
                    <th>Tasks Completed</th>
                    <th>Total Points</th>
                  </tr>
                </thead>
                <tbody>
                  {leaderboard.map((entry, index) => (
                    <tr class={user?.username === entry.username ? "is-current" : ""}>
                      <td>#{index + 1}</td>
                      <td>{entry.username}</td>
                      <td>{entry.completedCount}</td>
                      <td>{entry.totalPoints}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </>
      )}
    </main>

  <script defer>
      const CHART_COLORS = [
        'rgb(0, 133, 254)',
        'rgb(255, 99, 132)',
        'rgb(75, 192, 192)',
        'rgb(255, 205, 86)',
        'rgb(153, 102, 255)',
        'rgb(255, 159, 64)',
        'rgb(54, 162, 235)',
        'rgb(201, 203, 207)',
        'rgb(0, 255, 127)',
        'rgb(255, 105, 180)',
      ];

      async function buildGraph() {
        const canvas = document.getElementById('completionGraph');
        if (!canvas) return;

        const res = await fetch('/api/completions');
        if (!res.ok) return;
        const { completions, pointsById, playerUsernames, competitionStart, competitionEnd } = await res.json();

        // Group completions by user
        const byUser = {};
        for (const c of completions) {
          if (!byUser[c.username]) byUser[c.username] = [];
          byUser[c.username].push({
            taskId: c.task_id,
            time: new Date(c.completed_at),
            points: pointsById[c.task_id] || 0,
          });
        }

        const hasCompetitionStart = Boolean(competitionStart);
        const hasCompetitionEnd = Boolean(competitionEnd);
        const startMs = hasCompetitionStart ? new Date(competitionStart).getTime() : null;
        const endMs = hasCompetitionEnd ? new Date(competitionEnd).getTime() : null;

        // Collect all unique timestamps and sort them
        const allTimes = [...new Set(completions.map(c => new Date(c.completed_at).getTime()))].sort((a, b) => a - b);

        // Show a message when there are no players to chart.
        if (playerUsernames.length === 0) {
          const container = document.querySelector('.graph-card');
          if (container) container.innerHTML = '<p style="color: var(--small-text); text-align: center; padding: 24px;">No players found</p>';
          return;
        }

        const fallbackStart = startMs ?? allTimes[0] ?? Date.now();
        const rawFallbackEnd = endMs ?? allTimes[allTimes.length - 1] ?? fallbackStart;
        const fallbackEnd = Math.max(rawFallbackEnd, fallbackStart);

        // Build datasets using {x, y} point format for time scale
        const usernames = Array.isArray(playerUsernames) && playerUsernames.length > 0
          ? playerUsernames
          : Object.keys(byUser);
        const datasets = usernames.map((username, i) => {
          const events = byUser[username];
          let cumulative = 0;
          const pointsAtTime = new Map();
          for (const ev of events) {
            const eventTime = ev.time.getTime();
            pointsAtTime.set(eventTime, (pointsAtTime.get(eventTime) || 0) + ev.points);
          }

          // Build data array with explicit start/end anchors so every player starts bottom-left.
          let runningTotal = 0;
          const data = [{ x: fallbackStart, y: 0 }];

          for (const t of allTimes) {
            if (t < fallbackStart || t > fallbackEnd) continue;
            if (pointsAtTime.has(t)) {
              runningTotal += pointsAtTime.get(t);
            }
            data.push({ x: t, y: runningTotal });
          }

          const lastScore = data[data.length - 1]?.y ?? 0;
          data.push({ x: fallbackEnd, y: lastScore });


          const color = CHART_COLORS[i % CHART_COLORS.length];
          return {
            label: username,
            data,
            borderColor: color,
            backgroundColor: color,
            tension: 0.35,
            pointRadius: 3,
            pointHoverRadius: 5,
            cubicInterpolationMode: 'monotone',
            fill: false,
          };
        });

        // Determine x-axis min/max from competition times
        const xMin = fallbackStart;
        const xMax = fallbackEnd;

        new Chart(canvas, {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            plugins: {
              legend: {
                labels: {
                  color: '#A1B1D1',
                  font: { family: 'Orbitron, sans-serif', size: 12 },
                },
              },
              tooltip: {
                backgroundColor: '#151E2D',
                titleColor: '#e3e4e7',
                bodyColor: '#A1B1D1',
                borderColor: '#1f2b43',
                borderWidth: 1,
              },
            },
            scales: {
              x: {
                type: 'time',
                min: xMin,
                max: xMax,
                time: {
                  displayFormats: {
                    minute: 'HH:mm',
                    hour: 'MMM d, HH:mm',
                    day: 'MMM d',
                  },
                },
                ticks: { color: '#A1B1D1', font: { size: 11 }, maxRotation: 45 },
                grid: { color: 'rgba(31, 43, 67, 0.5)' },
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: 'Points', color: '#A1B1D1', font: { family: 'Orbitron, sans-serif' } },
                ticks: { color: '#A1B1D1' },
                grid: { color: 'rgba(31, 43, 67, 0.5)' },
              },
            },
          },
        });
      }

      buildGraph();
    </script>

    <style>
      .leaderboard-page {
        max-width: 960px;
        margin: 0 auto;
        padding: 32px 16px 64px;
        text-align: left;
      }

      .leaderboard-intro h1 {
        margin-bottom: 8px;
      }

      .leaderboard-rank {
        margin-top: 8px;
        color: var(--small-text);
      }

      .leaderboard-card {
        background: #111b2b;
        border-radius: 16px;
        padding: 24px;
        margin-top: 24px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
      }

      .leaderboard-table {
        width: 100%;
        border-collapse: collapse;
      }

      .leaderboard-table th,
      .leaderboard-table td {
        text-align: left;
        padding: 12px 8px;
        border-bottom: 1px solid #1f2b43;
      }

      .leaderboard-table th {
        color: var(--small-text);
        font-weight: 600;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }

      .leaderboard-table tr.is-current td {
        color: var(--beta-blue);
        font-weight: 600;
      }

      .leaderboard-empty {
        margin-top: 24px;
        padding: 20px 24px;
        border-radius: 12px;
        background: rgba(255, 174, 0, 0.08);
        border: 1px solid rgba(255, 174, 0, 0.25);
        color: var(--small-text);
      }

      .graph-section {
        margin-top: 48px;
      }
 
      .graph-section h2 {
        margin-bottom: 8px;
      }
 
      .graph-card {
        background: #111b2b;
        border-radius: 16px;
        padding: 24px;
        margin-top: 16px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
      }

      .leaderboard-frozen {
        margin-top: 48px;
        padding: 48px 32px;
        border-radius: 16px;
        background: rgba(255, 174, 0, 0.06);
        border: 1px solid rgba(255, 174, 0, 0.25);
        text-align: center;
      }

      .leaderboard-frozen h2 {
        color: #ffae00;
        margin: 0 0 12px;
        font-size: 1.4rem;
      }

      .leaderboard-frozen p {
        color: var(--small-text);
        margin: 0;
        font-size: 1rem;
        line-height: 1.6;
      }
    </style>
  </body>
</html>